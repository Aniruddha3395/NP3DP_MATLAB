#include "mex.h"
#include "matrix.h"
#include <iostream>
#include "string.h"
#include </usr/local/include/eigen3/Eigen/Eigen>
#include <stdio.h>
#include <vector>

Eigen::MatrixXd identify_bottom_layer(Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd);
Eigen::VectorXd linsp(double strt, double end, double stp);

void mexFunction (int _OutArgs, mxArray *MatlabOut[], int _InArgs, const mxArray *MatlabIn[] )
{
    // Define Input
    int v_cols = 3;
    int f_cols = 3;
    int n_cols = 3;
    Eigen::Map<Eigen::ArrayXXd,Eigen::Aligned> v (mxGetPr(MatlabIn[0]), mxGetNumberOfElements(MatlabIn[0])/v_cols, v_cols); 
    Eigen::Map<Eigen::ArrayXXd,Eigen::Aligned> f (mxGetPr(MatlabIn[1]), mxGetNumberOfElements(MatlabIn[1])/f_cols, f_cols); 
    Eigen::Map<Eigen::ArrayXXd,Eigen::Aligned> n (mxGetPr(MatlabIn[2]), mxGetNumberOfElements(MatlabIn[2])/n_cols, n_cols); 
    
    // Method 
    Eigen::MatrixXd fnew = identify_bottom_layer( v, f, n);

    // Define Output
    MatlabOut[0] = mxCreateDoubleMatrix(fnew.rows(), fnew.cols(), mxREAL);
    Eigen::Map<Eigen::ArrayXXd,Eigen::Aligned> M0 ( mxGetPr(MatlabOut[0]), fnew.rows(), fnew.cols() );
    M0 = fnew.array();
}

Eigen::MatrixXd identify_bottom_layer(Eigen::MatrixXd v, Eigen::MatrixXd f, Eigen::MatrixXd n)
{
	// This function identifies the vertices of bottom layer first based on the normal direction
	// INPUT = vertices (3n-by-3 matrix), faces (n-by-3 matrix) and normals (n-by-3 matrix) generated by the STL file.
	// OUTPUT = vertices of the of the bottom surface (m-by-3 matrix)

	Eigen::VectorXd indexv = linsp(1,v.rows(),1);		// indexing vertices
	Eigen::VectorXd indexn = linsp(1,n.rows(),1);		// indexing normals...same as indexing faces
	Eigen::MatrixXd nnew(n.rows(),7);
	nnew << n,f,indexn;
	Eigen::MatrixXd vnew(v.rows(),4);
	vnew << v,indexv; 

	// storing index of only those normals whose z direction is negative,
	// i.e. normal pointing downwards... i.e normals from bottom layer
	Eigen::MatrixXd	store = Eigen::MatrixXd::Constant(nnew.rows(),nnew.cols(),0);
	long int idx_n = 0;
	for (long int i=0;i<nnew.rows();++i)
	{
		if (nnew(i,2)<0)
		{
			store.block(idx_n,0,1,store.cols()) = nnew.block(i,0,1,nnew.cols());
			++idx_n;
		}
	}

	// using index of those normals to get the faces and hence the points associated with those faces
	Eigen::MatrixXd fnew = store.block(0,3,idx_n,3);
	return fnew;
}

Eigen::VectorXd linsp(double strt, double end, double stp)
{
    int sz;
    if (strt<=end && stp>0 || strt>=end && stp<0)
    {
        sz = int((end-strt)/stp)+1;
    }
    else
    {
        if (strt>=end)
        {
            std::cerr << "start value is greater than the end value for incement!" << std::endl;
            std::terminate();   
        }
        else
        {
            std::cerr << "start value is less than the end value for decrement!" << std::endl;
            std::terminate();   
        }
    }
    return Eigen::VectorXd::LinSpaced(sz,strt,strt+stp*(sz-1));
}